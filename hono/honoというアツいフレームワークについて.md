
honoというアツいフレームワークについて
https://qiita.com/StarduSt_cruSaderS/items/afd509a6666fc9c0495c

# honoというアツいフレームワークを調べてみる

最近「**hono**」という日本発のアツいフレームワークが界隈を賑わせているらしい。  
いつ頃に聞いたのかは覚えていないが、これほど注目されるOSSが日本から生まれているのは本当にすごい。

だいぶ波に乗り遅れた感はあるが、せっかくなので書いてみる。

## 記事の方針

いきなり全てを追うのは難しいので、記事を **2つ** に分けることにした。

1. **機能を調査する記事**  
2. **プロダクトを作成する記事**

## プロダクト構想

定番の「todoアプリ」では面白くない。  
そこで、**ChatGPTなどを使ったマルチエージェントシステム**を作ることを目標にする。  
まずはその前段として、**エージェントを複数登録できるサービス**を作ってみる予定。

## 今回のテーマ

今回は「**調べるだけの記事**」とする。  
honoについて何も知らないので、興味の赴くままに調べたい気持ちはあるが、  
まずは範囲を絞って、少しだけ調べてみることにする。

# hono の原点

**hono** はフレームワークとしてはかなり後発の存在だ。  
それにもかかわらず、すでに“歴史”と呼べるほどの地層が積み重なっている。  
この「積み重ね」こそが、honoがここまで成長してきた理由のひとつだと思う。

honoは **yusukebe** さんによる個人開発から始まった。  
（ちなみに、この方はあの「ボケて」を作った人でもある。すごい。）

> At first, I just wanted to create a web application on Cloudflare Workers.  
> But, there was no good framework that works on Cloudflare Workers.  
> So, I started building Hono.  
> I thought it would be a good opportunity to learn how to build a router using Trie trees.  
> Then a friend showed up with ultra crazy fast router called "RegExpRouter".  
> And I also have a friend who created the Basic authentication middleware.

彼がhonoを作り始めたのは、**Cloudflare Workers上で動くフレームワークが存在しなかった**から。  
必要に迫られて、そして「Trie木でRouterを実装してみたい」という純粋な技術的好奇心からだった。

彼のブログを遡ると、**perl時代から何度もフレームワークを作っては捨てる**という試行錯誤を繰り返してきたことが分かる。  
Plack::Request を使って “出来損ないの Sinatra” をいくつも作っていたというエピソードもある。  
その経験を通して、「リクエストオブジェクトさえあればフレームワークは意外と簡単に作れる」という感覚を掴んでいたようだ。

R25チャンネルで成田氏が語っていたように、  
> 「ビジョンや崇高なストーリーを語る経営者が増えた。  
> 成り立ってしまっている地味な企業の方が好感が持てる。」

まさに、**yusukebe氏のプロダクトの作り方**はそれに通じる。  
壮大なビジョンではなく、技術的な課題と興味から生まれた「手遊び的な美点」。  
honoは、そんな初期衝動と技術的探究心に駆動されて誕生したプロダクトだ。


# hono の特色

honoの最大の特色は、**どんな環境にでもデプロイできる**ことだ。

:::note info
どこにでもデプロイできる
:::

その理由は、**Web Standard API に則っている**からである。

> Using only Web Standard APIs, we could make it work on Deno and Bun.  
> When people asked "is there Express for Bun?", we could answer,  
> "no, but there is Hono". (Although Express works on Bun now.)

このように、Web標準のAPIだけで構成されているため、  
honoは [Cloudflare Workers](https://www.cloudflare.com/ja-jp/) だけでなく、  
**Deno** や **Bun** といった他のJavaScriptランタイムでも動作する。

ちなみに **Bun** は、徹底的な速さを追求したJSランタイムとして注目を集めている。  
（「環境」と聞くとインフラのように思えて身構えてしまうが、ここで言う“環境”はこの **JSランタイム** のことだ。）

つまり、honoはDenoやBunなどのモダンな実行環境に柔軟に対応しており、  
**どの環境でも同じように動く軽量で快適な開発体験**を提供してくれるフレームワークなのだ。


# 良い開発体験

honoは**デフォルトでTypeScriptを採用**している。  
これにより、最初から型安全な開発体験が保証されている。

さらに特筆すべきは、**Zod** や **tRPC** などと組み合わせた  
**型安全なAPI／フロントエンド開発**ができる点だ。

つまり、**バックエンドで定義したAPIを型安全にフロントエンドから呼び出せる！**  
これがめちゃくちゃ強い。

普段バックエンドにあまり触れない人にとって、OpenAPIのような仕組みは少し取っつきにくい。  
でも「宣言的にAPIを作れて、型まで共有できる」——そう考えるとtRPCの思想はとても魅力的だ。

tRPCは、[Clojure](https://clojure.org) の [cljc](https://clojure.org/guides/reader_conditionals) ファイルのようなもので、  
**バックエンドとフロントエンドで型を共有**できる。  
これがとても便利なのは、想像に難くない。  
型を二重管理するのは面倒だし、BFFを導入するにもコストがかかる。

Zodなどを利用した型安全な開発については、別の記事で詳しく触れる予定だ。  
ここでは、いよいよ **honoの本丸である Router** に乗り込んでいこう。


## 🧭 HonoのRouterとは？

honoの中心には「Router（ルーター）」がある。  
実はこの **Routerこそがhonoのコア機能** だ。

---

### 💡 なぜRouterが重要なのか？

Cloudflare Workers では **Web標準のAPI（Fetch APIなど）しか使えない**。  
そのため、Expressのような重い仕組みは動かない。  
求められたのは、**軽くて速いフレームワーク**。

だから、honoは「Routerだけで構成されるようなシンプルな仕組み」から始まった。

---

### 🧠 フレームワークの本質

どんなフレームワークも、最終的にやっていることはたった一つ。

> リクエストを受け取って、レスポンスを返す。

認証・セッション・SSRなどの複雑な機能も、  
その基本の上に積み上がっているにすぎない。

だからこそ、**Routerを理解することがhonoを理解する近道**。

---

### 🗂️ honoにある5つのRouter

honoには、目的や性能の違いによって5種類のRouterがある。

| Router名 | 特徴 |
|-----------|------|
| **RegExpRouter** | 正規表現ベース。柔軟で汎用的。 |
| **TrieRouter** | Trie木構造でルーティング。超高速。 |
| **SmartRouter** | 上記2つを自動で使い分ける。 |
| **LinearRouter** | シンプルで直線的。実験的要素。 |
| **PatternRouter** | 独自のパターンマッチ方式。尖っている。 |

---

### 🎯 覚えておくべきRouter

重要なのはこの2つだけ！

- **RegExpRouter**
- **TrieRouter**

残りは実験的・特殊な用途向け。  
SmartRouterはこの2つを「いいとこ取り」して自動選択してくれる。

---

### ✅ まとめ

- honoは「軽量なRouter中心の設計」  
- Routerは「リクエストをルートに振り分ける心臓部」  
- Cloudflare Workersの制約が、軽量Router設計を生んだ  
- 実際に使うのは主に **RegExpRouter** と **TrieRouter**

👉 honoを理解するなら、まずRouterを知るべし！

# 他のライブラリにおける Router の仕組み

Hono の Router の特徴を理解する前に、まず他のライブラリではどのように Router が作られているのかを見てみましょう。  
そうすることで、Hono の Router がどこで優れているのかが分かりやすくなります。



## Router の基本的な役割

Router の目的はシンプルで、「**URLをHandler（処理）に紐づける**」ことです。  
つまり「どのURLにアクセスされたとき、どの処理を行うか」を決める仕組みです。

例：  
`/users/:id/:repository-id`

このようなパスでは、`:id` や `:repository-id` のようなワイルドカード（パラメータ）に対応する必要があります。


## 素朴な実装の考え方

最も単純な方法は、URLパターンを**正規表現**で表し、それをキーとして登録する方法です。

例：  
`^/users/([^/]+)/([^/]+)`

このようにして「URLパターン → Handler」を対応づけ、リクエストが来たら上から順にパターンを照合して処理を実行します。

この「上から順にマッチングする」という設計は、**React Router** などでも見られます。



## React Router の例

React Router では、ユーザーが特定のURLに移動した際に、`Routes` コンポーネント内の各 `Route` を順番に評価します。

- 現在のURLと一致する `path` が見つかれば、その `Route` のコンポーネントをレンダリング  
- 一致するものがなければ、`*`（ワイルドカード）を使ったフォールバックルートで404を処理  

このように、React Router も「**上から順に評価して最初に一致したルートを採用する**」というシンプルで直感的な仕組みになっています。

---

## まとめ

一般的なRouterの流れは以下の通りです。

1. URLとHandlerを紐づける  
2. 正規表現やパラメータで動的パスに対応  
3. 上から順にルートを評価して一致を確認  

この仕組みをベースに、各フレームワークはパフォーマンスや開発体験を最適化しています。  
次に、Honoがこれをどう発展させているのかを見ていきましょう。


# 1. RegExpRouter

Hono の Router の中で、最も高速なのが **RegExpRouter** です。  
理由は、すべてのルートをひとつの正規表現にまとめてマッチングする仕組みを採用しているからです。

通常の Router では、ルートを順番に1つずつ照合します。  
しかし RegExpRouter では、次のようにルートをまとめて1度に判定します。

(ルート1|ルート2|ルート3|...)

このように一発で Handler を特定できるため、多数のルートを持つアプリケーションでも非常に高速に動作します。

この仕組みのもとになったのは、Perl の **Router::Boom** というライブラリです。  
Router::Boom は複数のルートパターンを論理 OR（|）でまとめて処理し、  
各ルートを順に確認する必要をなくすことで高いパフォーマンスを実現しています。

つまり、RegExpRouter は「正規表現の力を最大限に活用したルーティング」方式です。

# 2. TrieRouter

**TrieRouter** は、RegExpRouter よりわずかに遅いものの、依然として非常に高速な Router です。  
その理由は、**Trie Tree（トライ木）** と呼ばれるデータ構造を利用しているからです。

Trie Tree は、共通のプレフィクス（接頭部分）を持つデータを効率的に管理するための木構造です。  
URL は「/」で区切られた階層構造を持つため、これをそのまま木として表現できます。

たとえば、次のようなルートがあるとします。

- /users/:user-id/articles/:article-id  
- /users/:user-id/articles  
- /users/:user-id/profile  
- /settings  

この場合、TrieRouter は `/users` をルートノードとして、その下に `:user-id`、さらにその下に `articles` や `profile` といった枝を持ちます。

もしユーザーが `/settings` にアクセスしたとき、  
ルート `/users` とは共通部分がないため、`/users` 以下の枝（ルート）をすべて無視できます。  
つまり、**「枝切り」** によって不要な探索を省略できるのです。

この構造のおかげで、TrieRouter は多くのルートを持つアプリケーションでも効率的にルーティングを行えます。

Hono では、基本的に **RegExpRouter** と **TrieRouter** の2つでほとんどのケースをカバーできます。  
さらに **SmartRouter** を使えば、状況に応じて RegExpRouter を優先的に選択することも可能です。

残る Router は、より特殊な目的で使われる「尖った」タイプのものになります。

# LinearRouter と PatternRouter

## LinearRouter

**LinearRouter** は、最も一般的でシンプルな Router です。  
ルートを「登録された順」に上から順番に確認していきます。

つまり、最初に一致したルートが採用されるため、  
**ワイルドカード的なルートを先に登録してはいけない** という制約があります。  
（たとえば、`/users/:id` より前に `/users/*` を登録すると、すべてのリクエストが `/users/*` に吸われてしまう）

この Router の強みは、「登録の速さ」です。  
ルート登録時に特別な整形処理を行わないため、**lazy（遅延的）な登録**が可能で、初期構築が非常に軽量です。


## PatternRouter

**PatternRouter** は、Hono における Router の中でも特に「尖った」存在です。  
なんと、Router 全体のサイズが **15KB 以下** という超軽量設計になっています。

この軽さは、Cloudflare Workers や Deno Deploy など、  
リソース制約のある環境や個人開発の無料枠などで大きな利点となります。

つまり、**最小限のリソースで最大限の機能を発揮する Router** といえます。


## まとめ

ここまで見てきたように、Hono には用途や目的に応じた複数の Router が存在します。  
軽量性・速度・柔軟性など、それぞれの Router が異なる強みを持っています。

そして何より、このフレームワークを支えているのは **コミュニティの力** です。  
Hono の開発者である **yusukebe 氏** は、国内外に向けて積極的に情報発信や貢献を行い、  
その結果として Hono は今の形に成長しました。

技術的な面白さに加え、**「人とコミュニティで育つフレームワーク」** という点こそ、Hono の最大の魅力といえるでしょう。
