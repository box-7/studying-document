# サーバー送信イベントの使用

[MDN: サーバー送信イベントの使用](https://developer.mozilla.org/ja/docs/Web/API/Server-sent_events/Using_server-sent_events)



サーバー送信イベント (Server-Sent Events) を使用するウェブアプリケーションの開発は簡単。  
サーバー上でフロントエンドへイベントを流すために必要になるコードはわずか。  
クライアント側のコードはウェブソケットでイベントを扱う部分とほぼ同じ。  
これは単方向の接続なので、クライアントからサーバーへイベントを送信することはできない。

---

## サーバーからのイベントの受信

サーバー送信イベント API は **EventSource インターフェイス**に含まれる。

### EventSource インスタンスの作成
サーバーへの接続を開始するには、新しい EventSource オブジェクトを作成して URI を指定する。

```js
const evtSource = new EventSource("ssedemo.php");
```

別オリジンの場合は URI とオプションを指定する。
```js
const evtSource = new EventSource("//api.example.com/ssedemo.php", {
  withCredentials: true,
});
```

### message イベントの待ち受け
```js
evtSource.onmessage = (event) => {
  const newElement = document.createElement("li");
  const eventList = document.getElementById("list");

  newElement.textContent = `message: ${event.data}`;
  eventList.appendChild(newElement);
};
```

### カスタムイベントの待ち受け

サーバーから送られてくるメッセージには event フィールドを付けられる

例えばサーバーが次のように送信する場合：
```
event: ping
data: {"time":"2025-09-07T12:00:00Z"}
```

クライアント側は addEventListener("ping", handler) を使うと、このイベントだけを処理できる
```js
evtSource.addEventListener("ping", (event) => {
  // サーバーから送られてきた JSON データを取り出す
  const time = JSON.parse(event.data).time;

  // li 要素を作って HTML に追加
  const newElement = document.createElement("li");
  newElement.textContent = `ping at ${time}`;

  const eventList = document.getElementById("list");
  eventList.appendChild(newElement);
});
```

### サーバーからのイベントの送信
サーバー側のスクリプトは MIME タイプ text/event-stream で応答する必要がある。
各通知は 2 つの改行で終わるテキストのブロック。

PHP の例
```php
date_default_timezone_set("America/New_York");
header("X-Accel-Buffering: no");
header("Content-Type: text/event-stream");
header("Cache-Control: no-cache");

$counter = rand(1, 10);
while (true) {
  // "ping" イベントを毎秒送信
  echo "event: ping\n";
  $curDate = date(DATE_ISO8601);
  echo 'data: {"time": "' . $curDate . '"}';
  echo "\n\n";

  // シンプルなメッセージをランダムな間隔で送信
  $counter--;
  if (!$counter) {
    echo 'data: This is a message at time ' . $curDate . "\n\n";
    $counter = rand(1, 10);
  }

  if (ob_get_contents()) {
    ob_end_flush();
  }
  flush();

  // クライアントが接続を中止したらループを抜ける
  if (connection_aborted()) break;

  sleep(1);
}
```

### エラー処理
問題が発生した場合（ネットワークのタイムアウトやアクセス制御の問題など）、エラーイベントが発生する。
これを処理するには onerror コールバックを実装する。

```js
evtSource.onerror = (err) => {
  console.error("EventSource failed:", err);
};
```

### イベントストリームを閉じる
既定では接続は自動で再起動する。
手動で閉じるには .close() を使う。

```js
evtSource.close();
```

### イベントストリームの形式
イベントストリームは UTF-8 のテキストデータ。
2 つの改行文字でメッセージを区切る。
コメント行（先頭が :）は無視される。

### フィールド
フィールド
受信した各メッセージには、以下のフィールドの組み合わせが、 1 行 1 つで現れます。

#### event
記述されるイベントの種別を識別する文字列です。指定された場合、イベントはブラウザー内で、指定されたイベント名のイベントリスナーへ送られます。ウェブサイトのソースコードで名前付きイベントを待ち受けするには addEventListener() を使用してください。メッセージにイベント名が指定されなかった場合は、 onmessage ハンドラーが呼び出されます。

#### data
メッセージのデータフィールドです。 EventSource が data: で始まる、複数の連続した行を受け取ったときは、それらを連結して各項目の間に改行文字を挿入します。末尾の改行は取り除かれます。

#### id
EventSource オブジェクトの最後のイベント ID の値に設定するイベント ID です。

#### retry
再接続時間です。サーバーへの接続が切れた場合、ブラウザーは指定した時間だけ待ってから再接続を試みます。これは整数値でなければならず、再接続時間をミリ秒単位で指定します。整数値以外が指定された場合は、このフィールドは無視されます。

他のフィールド名は、すべて無視されます。

メモ: 行にコロンが含まれない場合は行全体がフィールド名とし、値は空文字列として扱います。

#### 例
データのみのメッセージ
以下の例では、3 つのメッセージが送信されています。最初のメッセージはコロン文字から始まっているため、コメントです。前述したように、コメントはメッセージが定期的に送信されない可能性がある場合のキープアライブとして利用できます。

2 番目のメッセージには data フィールドがあり、その値は "some text" です。 3 番目のメッセージは data フィールドで、値は "another message\nwith two lines" です。値に改行文字があることに注意してください。

```bash

: this is a test stream

data: some text

data: another message
data: with two lines
```

### 名前付きイベント
こちらの例では、名前付きイベントをいくつか送信しています。それぞれのイベントではイベント名が event フィールドで指定されており、また data フィールドではクライアントでの処理に必要なデータを含む、適切な JSON 文字列の値が指定されています。もちろん、 data フィールドには任意の文字列データを入れることができます。 JSON である必要はありません。

```bash
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}

event: userdisconnect
data: {"username": "bobby", "time": "02:34:23"}

event: usermessage
data: {"username": "sean", "time": "02:34:36", "text": "Bye, bobby."}
```

### 組み合わせ
名前なしのメッセージや種類の付いたイベントだけを使用しなければならない訳ではありません。これらを単一のイベントストリーム内で混用することができます。

```bash
event: userconnect
data: {"username": "bobby", "time": "02:33:48"}

data: Here's a system message of some kind that will get used
data: to accomplish some task.

event: usermessage
data: {"username": "bobby", "time": "02:34:11", "text": "Hi everyone."}
```