# Nginx Beginner’s Guide 日本語版
https://nginx.org/en/docs/beginners_guide.html


## 目次
- Beginner’s Guide
- Starting, Stopping, and Reloading Configuration
- Configuration File’s Structure
- Serving Static Content
- Setting Up a Simple Proxy Server
- Setting Up FastCGI Proxying

---

## はじめに

このガイドでは、Nginx の基本的な紹介と、いくつかの簡単なタスクの実施方法を説明します。  
読者のマシンに Nginx が既にインストールされていることを前提としています。  
もしインストールされていない場合は「Installing nginx」ページを参照してください。

このガイドでは以下を説明します：  
- Nginx の起動と停止、設定リロード方法  
- 設定ファイルの構造  
- 静的コンテンツの配信方法  
- Nginx をプロキシサーバーとして設定する方法  
- FastCGI アプリケーションとの接続方法

---

## Nginx のプロセス構造

Nginx には 1 つのマスタープロセスと複数のワーカープロセスがあります。

- **マスタープロセスの主な役割**  
  - 設定の読み込みと評価  
  - ワーカープロセスの管理

- **ワーカープロセスの主な役割**  
  - 実際のリクエスト処理

Nginx は **イベントベースモデル** と OS 依存の仕組みを使い、ワーカープロセス間で効率的にリクエストを分配します。

ワーカープロセスの数は設定ファイルで定義されます。  
- 固定値に設定可能  
- または利用可能な CPU コア数に応じて自動調整することも可能（`worker_processes` を参照）

---

### 設定ファイルの場所
Nginx とそのモジュールの動作は設定ファイルで決定されます。  
デフォルトでは設定ファイルは `nginx.conf` という名前で、以下のディレクトリに配置されます：


## 起動、停止、設定リロード
nginx を起動するには、実行ファイルを実行します。nginx が起動したら、-s パラメータを指定して実行ファイルを呼び出すことで制御できます。以下の構文を使用します:
```
nginx -s signal
```
ここでsignalは次のいずれかです:
```
stop — 強制終了
quit — 正常終了
reload — 設定ファイルの再読み込み
reopen — ログファイルの再オープン
```
例えば、ワーカープロセスが現在のリクエスト処理を完了するのを待たずにnginxプロセスを停止するには、次のコマンドを実行します：
```
nginx -s quit
```
このコマンドは、nginxを起動したのと同じユーザーで実行する必要があります。

設定ファイルへの変更は、設定再読み込みコマンドをnginxに送信するか、nginxを再起動するまで適用されません。設定を再読み込みするには以下を実行します：
```
nginx -s reload
```
マスタープロセスが設定再読み込み信号を受信すると、新しい設定ファイルの構文妥当性をチェックし、その設定を適用しようと試みます。成功した場合、マスタープロセスは新しいワーカープロセスを起動し、古いワーカープロセスにシャットダウンを要求するメッセージを送信します。失敗した場合、マスタープロセスは変更をロールバックし、古い設定で動作を継続します。シャットダウン命令を受信した古いワーカープロセスは、新規接続の受け入れを停止し、既存のリクエストがすべて処理されるまでサービスを提供し続けます。その後、古いワーカープロセスは終了します。

killユーティリティなどのUnixツールを使用してnginxプロセスにシグナルを送信することも可能です。この場合、指定されたプロセスIDを持つプロセスに直接シグナルが送信されます。nginxマスタープロセスのプロセスIDは、デフォルトで/usr/local/nginx/logsまたは/var/runディレクトリ内のnginx.pidに書き込まれます。例えば、マスタープロセスIDが1628の場合、nginxを正常にシャットダウンさせるQUITシグナルを送信するには、以下を実行します：
```
kill -s QUIT 1628
```
実行中のすべての nginx プロセスの一覧を取得するには、ps ユーティリティを次のように使用できます：
```
ps -ax | grep nginx
```
nginx へのシグナル送信の詳細については、「nginx の制御」を参照してください。

---

## 設定ファイルの構造

nginxは、設定ファイルで指定されるディレクティブによって制御されるモジュールで構成されています。ディレクティブは単純ディレクティブとブロックディレクティブに分類されます。単純ディレクティブは名前とスペースで区切られたパラメータで構成され、セミコロン(;)で終了します。ブロックディレクティブは単純ディレクティブと同じ構造ですが、セミコロンではなく、中括弧({と})で囲まれた一連の追加指示で終了します。ブロックディレクティブが中括弧内に他のディレクティブを含む場合、それはコンテキストと呼ばれます（例：events、http、server、location）。

設定ファイル内でいずれのコンテキストにも属さないディレクティブは、メインコンテキストに属するとみなされます。eventsディレクティブとhttpディレクティブはメインコンテキストに、serverディレクティブはhttpコンテキストに、locationディレクティブはserverコンテキストに属します。

行の先頭にある#記号以降の文字列はコメントとして扱われます。


---

## 静的コンテンツの配信

ウェブサーバーの重要なタスクの一つは、ファイル（画像や静的HTMLページなど）の提供です。リクエストに応じて、異なるローカルディレクトリ（HTMLファイルを含む可能性のある/data/wwwと画像を含む/data/images）からファイルを提供する例を実装します。これには設定ファイルの編集と、httpブロック内に2つのlocationブロックを含むサーバーブロックの設定が必要です。

まず、/data/www ディレクトリを作成し、任意のテキストコンテンツを含む index.html ファイルを配置します。次に /data/images ディレクトリを作成し、いくつかの画像を配置します。

次に設定ファイルを開きます。デフォルトの設定ファイルには既に複数のサーバーブロック例が含まれていますが、ほとんどがコメントアウトされています。現時点ではこれらのブロックを全てコメントアウトし、新しいサーバーブロックを開始します：

```
http {
    server {
    }
}
```

**自分メモ**
```
// 自分のプロジェクト
// etc/nginx/nginx.conf (ec2ルートディレクトリ直下)

server {
        listen 80;
        server_name aws-intro-sample777.com;

        # HTTPからHTTPSへリダイレクト（任意）
        // 301 は「恒久的なリダイレクト（Moved Permanently）」のステータスコード
        // $host はリクエストされたホスト名（例: aws-intro-sample777.com）
        // $request_uri はリクエストされたパスやクエリ（例: /index.html?foo=bar）
        return 301 https://$host$request_uri;
}
```

一般的に設定ファイルには、リスンするポートやサーバー名で区別される複数のサーバーブロックを含めることができます。nginxがリクエストを処理するサーバーを決定すると、リクエストヘッダーで指定されたURIを、サーバーブロック内で定義されたlocationディレクティブのパラメータと照合します。

サーバーブロックに以下のlocationブロックを追加します：
```
 // URI の先頭が / のリクエストすべて にマッチ
location / {
    root /data/www;
}
```
| リクエスト URI | 実際のファイルパス |
|---------------|------------------|
| `/`           | `/data/www/` （もし `index.html` があれば返す） |
| `/index.html` | `/data/www/index.html` |
| `/some/example.html` | `/data/www/some/example.html` |  

このlocationブロックは、リクエストのURIと比較する「/」プレフィックスを指定します。一致するリクエストの場合、URIはrootディレクティブで指定されたパス（つまり/data/www）に追加され、ローカルファイルシステム上の要求されたファイルへのパスが形成されます。複数の一致するlocationブロックがある場合、nginxは最も長いプレフィックスを持つものを選択します。上記のロケーションブロックはプレフィックスの長さが1と最短であるため、他のすべてのロケーションブロックが一致しない場合にのみ使用されます。

次に、2つ目のロケーションブロックを追加します：
```
 // URI の先頭が/images/ のリクエストすべて にマッチ
location /images/ {
    root /data;
}
```
これは /images/ で始まるリクエストに一致します（location / も同様のリクエストに一致しますが、プレフィックスが短くなります）。

**自分メモ**
```
// 自分のプロジェクト
// etc/nginx/nginx.conf (ec2ルートディレクトリ直下)

location /records {
        // リクエストをバックエンドサーバー（Node.jsなど）に転送
        // backend/server.ts
        proxy_pass http://localhost:4000;
        // 元のホスト名をバックエンドに渡す
        proxy_set_header Host $host;
        // クライアントのIPアドレスをバックエンドに渡す
        proxy_set_header X-Real-IP $remote_addr;
        // プロキシ経由時の元のIPアドレスを渡す
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        // リクエストのプロトコル（http/https）を渡す
        proxy_set_header X-Forwarded-Proto $scheme;
}
```

サーバーブロックの設定は最終的に以下のようになります：
```
server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
}
```
これで標準ポート80でリスニングするサーバーの設定が完了し、ローカルマシンで http://localhost/ にアクセス可能になります。/images/ で始まるURIのリクエストに対しては、サーバーは /data/images ディレクトリからファイルを送信します。例えば、http://localhost/images/example.png へのリクエストに対しては、nginx は /data/images/example.png ファイルを送信します。該当ファイルが存在しない場合、nginxは404エラーを示す応答を返します。/images/で始まらないURIのリクエストは/data/wwwディレクトリにマッピングされます。例えば、http://localhost/some/example.htmlリクエストに対しては、nginxは/data/www/some/example.htmlファイルを送信します。

新しい設定を適用するには、nginxが起動していない場合は起動するか、nginxのマスタープロセスにreloadシグナルを送信します。以下のコマンドを実行してください：
```
nginx -s reload
```

期待通りに動作しない場合は、/usr/local/nginx/logs または /var/log/nginx ディレクトリ内の access.log および error.log ファイルで原因を調査してください。







# シンプルなプロキシサーバーの設定
nginxの一般的な用途の一つは、プロキシサーバーとして設定することです。これは、リクエストを受け取り、プロキシ対象のサーバーに転送し、応答を取得してクライアントに送信するサーバーを意味します。

→ Nginx が「受け取り役」で、Nginx 自身が バックエンドサーバーにリクエストを代理送信

ここでは、ローカルディレクトリ内の画像ファイルのリクエストを処理し、その他の全リクエストをプロキシ先サーバーへ転送する基本プロキシサーバーを設定します。この例では、両サーバーを単一のnginxインスタンス上で定義します。

まず、nginx設定ファイルに以下の内容でサーバーブロックを追加し、プロキシ先サーバーを定義します：
```
server {
    listen 8080;
    // location / の中に root が無いので serverブロックの root (/data/up1) を使う
    root /data/up1;

    location / {
    }
}
```
これはポート8080でリスンする簡易サーバーです（従来は標準ポート80を使用するためlistenディレクティブは指定されていませんでした）。すべてのリクエストをローカルファイルシステムの/data/up1ディレクトリにマッピングします。このディレクトリを作成し、index.htmlファイルを配置してください。rootディレクティブがserverコンテキスト内に配置されている点に注意してください。このようなrootディレクティブは、リクエストの処理に選択されたlocationブロックに独自のrootディレクティブが含まれていない場合に使用されます。

→ // location / の中に root が無いので serverブロックの root (/data/up1) を使う

次に、前のセクションのサーバー設定を使用し、プロキシサーバー設定に変更します。最初のlocationブロックに、プロキシ先サーバーのプロトコル、名前、ポートをパラメータで指定したproxy_passディレクティブを追加します（この例ではhttp://localhost:8080です）：
```
server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location /images/ {
        root /data;
    }
}
```
現在「/images/」プレフィックス付きリクエストを「/data/images」ディレクトリ下のファイルにマッピングしている2番目のlocationブロックを修正し、一般的なファイル拡張子を持つ画像リクエストに対応させます。修正後のlocationブロックは以下のようになります：
```
location ~ \.(gif|jpg|png)$ {
    root /data/images;
}
```
このパラメータは、.gif、.jpg、または.pngで終わるすべてのURIに一致する正規表現です。正規表現の前には~を付ける必要があります。対応するリクエストは/data/imagesディレクトリにマッピングされます。

nginxがリクエストを処理するロケーションブロックを選択する際、まずプレフィックスを指定するlocationディレクティブを確認し、最も長いプレフィックスを持つlocationを記憶します。次に正規表現をチェックします。正規表現に一致した場合、nginxはこのlocationを選択し、一致しない場合は先に記憶したlocationを選択します。

プロキシサーバーの最終的な設定は次のようになります：
```
server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}
```
このサーバーは、.gif、.jpg、または.pngで終わるリクエストをフィルタリングし、それらを/data/imagesディレクトリにマッピングします（rootディレクティブのパラメータにURIを追加することで）。その他のすべてのリクエストは、上記で設定したプロキシサーバーに渡されます。

新しい設定を適用するには、前のセクションで説明したようにnginxにreloadシグナルを送信します。

プロキシ接続をさらに設定するために使用できるディレクティブは他にも多数あります。

## FastCGI プロキシの設定

Nginx は FastCGI サーバーにリクエストをルーティング可能です。PHP などのアプリケーションで使用されます。

→ FastCGI は PHP や Python などのサーバーサイド言語向けのプロトコルなので、省略
