# なぜ Vite なのか
### 問題点

ブラウザで ES Modules が使えなかった頃、開発者は JavaScript をモジュール化して書くネイティブな手段がありませんでした。そのため、webpack や Rollup、Parcel などのツールを使って、ソースモジュールを解析・結合してブラウザで動かす「バンドリング」の概念が生まれました。

しかし、大規模なアプリケーションでは数千ものモジュールを扱うことも珍しくなく、JavaScript ベースのツールではパフォーマンスのボトルネックが顕著になります。開発サーバーの起動に数分かかることもあり、HMR（Hot Module Replacement）を使ってもブラウザへの反映に数秒かかる場合があります。この遅いフィードバックループは開発者の生産性や満足度に大きく影響します。

Vite は、ブラウザでのネイティブ ES モジュールの利用と、コンパイル済みネイティブ言語で書かれた JavaScript ツールの台頭を活用することで、これらの問題を解決します。

### 開発サーバーの遅い起動

従来のバンドラーでは、開発サーバーを起動する際にアプリ全体を解析・ビルドする必要がありました。

Vite はモジュールを 依存モジュール と ソースコード に分けて処理します。

- 依存モジュールはほとんどが変更されないプレーンな JavaScript で、大規模ライブラリは処理コストも高いです。

Vite は依存モジュールを esbuild で事前バンドルします。esbuild は Go 言語で書かれており、従来の JavaScript ベースバンドラーより 10～100 倍高速です。

- ソースコードは JSX、CSS、Vue/Svelte コンポーネントなど変換が必要な場合があり、頻繁に編集されます。

ソースコードはネイティブ ESM でブラウザに提供され、必要な時だけ変換・配信されます。条件付きの動的インポートは実際に必要な時のみ処理されます。

バンドル型 vs ネイティブ ESM 型の開発サーバー

バンドル型：全モジュールをまとめて解析・配信、起動までに時間がかかる

ネイティブ ESM 型：依存モジュールを事前バンドルし、ソースコードは必要時に配信。動的インポートもオンデマンド

### 更新の遅さ

従来のバンドラーでは、ファイル編集時に全バンドルを再構築する必要があるため、アプリが大きいと更新速度が低下します。HMR で部分的に差し替え可能でも、規模が大きくなると遅くなります。

Vite では ネイティブ ESM による HMR を採用。編集されたモジュールと最も近い HMR 境界間のみを無効化するため、アプリ規模に関係なく高速に更新できます。

さらに、HTTP ヘッダーを活用して全ページリロードも高速化。依存モジュールは強力にキャッシュされ、再リクエストを避けます。

### なぜ本番ではバンドルするのか

ネイティブ ESM は広くサポートされていても、ネストした import によるネットワークラウンドトリップの増加で、本番環境では非効率です。

本番では ツリーシェイキング、遅延ロード、チャンク分割 により最適な読み込みパフォーマンスを確保する必要があります。

Vite は事前設定されたビルドコマンドでパフォーマンス最適化を組み込み、開発サーバーと本番ビルド間の整合性も保ちます。

### なぜ esbuild で本番バンドルしないのか

Vite は開発中の依存モジュール事前バンドルに esbuild を使いますが、本番ビルドには使いません。

現状の Vite のプラグイン API は esbuild を本番バンドラーとして使うのに適していません。

Rollup の柔軟なプラグイン API とインフラが Vite の成功に寄与しており、性能と柔軟性のバランスのため Rollup を採用しています。

Rollup は parser を SWC に変更するなど性能改善を進めており、将来的には Rust 移植版 Rolldown に置き換えられる可能性があります。

### 他のノンバンドル型ビルドツールとの関係

WMR（Preact チーム）に触発され、Vite のユニバーサル Rollup プラグイン API が開発されました。

Snowpack もネイティブ ESM ディベロップメントサーバーでした。Vite の依存事前バンドルは Snowpack v1（現 esinstall）に影響を受けています。

@web/dev-server も Vite 1.0 の Koa ベース開発サーバーに影響を与えています。

現在、これらのツールの多くはメンテナンスされていませんが、Vite はその経験を生かして進化しています。